import { __decorate, __metadata } from 'tslib';
import { Injectable, Input, Directive, ElementRef, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReplaySubject, Subject, combineLatest } from 'rxjs';
import { map } from 'rxjs/operators';

/**
 * A internal utility service.
 */
import * as ɵngcc0 from '@angular/core';
let MathJaxService = class MathJaxService {
    /**
     * A internal utility service.
     */
    constructor() {
        /**
         * Signals when the MathJax object is ready.
         */
        this.MathJaxHub$ = new ReplaySubject();
    }
    /**
     * Must call `init` method explicitly during module initialization.
     */
    init() {
        /**
         * Create a global variable.
         */
        window.mathJaxHub$ = this.MathJaxHub$;
    }
};
MathJaxService.ɵfac = function MathJaxService_Factory(t) { return new (t || MathJaxService)(); };
MathJaxService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MathJaxService, factory: MathJaxService.ɵfac });

/**
 * Typeset the content or expressions using MathJax library.
 */
let MathJaxDirective = class MathJaxDirective {
    constructor(el, service) {
        /**
         * Observes the change of the input expression.
         */
        this.expressionChangeSubject = new ReplaySubject();
        /**
         * Observes the completion of the initial MathJax typesetting.
         */
        this.mathJaxTypesetSubject = new Subject();
        this.mathJaxHub$ = service.MathJaxHub$;
        this.element = el.nativeElement;
        this.typesetSubscription = combineLatest([this.mathJaxHub$, this.mathJaxTypesetSubject])
            .subscribe(() => {
            MathJax.Hub.Queue(['Typeset', MathJax.Hub, this.element]);
        });
        this.allJax$ = combineLatest([this.mathJaxHub$, this.mathJaxTypesetSubject]).pipe(map(() => MathJax.Hub.getAllJax(this.element)));
        this.expressionChangeSubscription = combineLatest([this.allJax$, this.expressionChangeSubject])
            .subscribe(([jax, updateValue]) => updateValue.forEach(v => MathJax.Hub.Queue(() => {
            // Stop pushing messages to the queue when the component is being destroyed.
            if (!this.isDestroying) {
                return jax[v.order].Text(v.value);
            }
        })));
    }
    ngAfterViewInit() {
        this.hubSubscription = this.mathJaxHub$
            .subscribe(() => {
            MathJax.Hub.Queue(['Typeset', MathJax.Hub, this.element]);
            MathJax.Hub.Queue(['MathJaxTypeset', this]);
        });
    }
    /**
     * Explicitly trigger the MathJax typeset process.
     *
     * This is useful if the content is loaded dynamically.
     */
    MathJaxTypeset() {
        this.mathJaxTypesetSubject.next();
    }
    ngOnChanges(changes) {
        const expressions = changes.MathJaxExpressions;
        // Shortcut if there's nothing to update.
        if (!(expressions.currentValue instanceof Array)) {
            return;
        }
        // Update only the changed expressions.
        const updateValues = expressions.currentValue
            .map((cv, i) => (expressions.previousValue ? expressions.previousValue[i] !== cv : true) ?
            {
                value: expressions.currentValue[i],
                order: i
            }
            : undefined)
            .filter(v => v);
        this.expressionChangeSubject.next(updateValues);
    }
    ngOnDestroy() {
        this.isDestroying = true;
        this.expressionChangeSubscription.unsubscribe();
        this.hubSubscription.unsubscribe();
        this.typesetSubscription.unsubscribe();
        this.mathJaxTypesetSubject.complete();
        this.expressionChangeSubject.complete();
    }
};
MathJaxDirective.ɵfac = function MathJaxDirective_Factory(t) { return new (t || MathJaxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MathJaxService)); };
MathJaxDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MathJaxDirective, selectors: [["mathjax"], ["", "mathjax", ""]], inputs: { MathJaxExpressions: ["mathjax", "MathJaxExpressions"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input('mathjax'),
    __metadata("design:type", Array)
], MathJaxDirective.prototype, "MathJaxExpressions", void 0);
MathJaxDirective = __decorate([ __metadata("design:paramtypes", [ElementRef, MathJaxService])
], MathJaxDirective);

/**
 * @author davidshen84
 */
var MathJaxModule_1;
/**
 * Module configuration class.
 *
 * @example
 *
 * {
 *   version: '2.7.5',
 *   config: 'TeX-AMS_HTML',
 *   hostname: 'cdnjs.cloudflare.com'
 * }
 */
class ModuleConfiguration {
}
/**
 * Module to load and configure the MathJax library.
 *
 * @example
 *
 * MathJaxModule.config(
 * {
 *     version: '2.7.5',
 *     config: 'TeX-AMS_HTML',
 *     hostname: 'cdnjs.cloudflare.com'
 * })
 */
let MathJaxModule = MathJaxModule_1 = class MathJaxModule {
    constructor(service, moduleConfig) {
        service.init();
        /**
         * Define the **function string** to be inserted into the mathjax configuration script block.
         */
        const mathJaxHubConfig = (() => {
            MathJax.Hub.Config({
                skipStartupTypeset: true,
                messageStyle: 'none',
                tex2jax: { preview: 'none' }
            });
            MathJax.Hub.Register.StartupHook('End', () => {
                window.mathJaxHub$.next();
                window.mathJaxHub$.complete();
            });
        }).toString();
        if (moduleConfig) {
            /**
             * Insert the MathJax configuration script into the Head element.
             */
            (function () {
                const script = document.createElement('script');
                script.type = 'text/x-mathjax-config';
                script.text = `(${mathJaxHubConfig})();`;
                document.getElementsByTagName('head')[0].appendChild(script);
            })();
            /**
             * Insert the script block to load the MathJax library.
             */
            (function (version, config, hostname) {
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = `https://${hostname}/ajax/libs/mathjax/${version}/MathJax.js?config=${config}`;
                script.async = true;
                document.getElementsByTagName('head')[0].appendChild(script);
            })(moduleConfig.version, moduleConfig.config, moduleConfig.hostname);
        }
    }
    /**
     * Configure the provider for hte module.
     *
     * @deprecated Use forRoot or forChild method instead.
     * @param forRoot Make sure it is set to `true` for the root module and `false` for any child module.
     * @param moduleConfiguration A {ModuleConfiguration} instance.
     */
    static config(forRoot = true, moduleConfiguration = {
        version: '2.7.5',
        config: 'TeX-AMS_HTML',
        hostname: 'cdnjs.cloudflare.com'
    }) {
        return forRoot ? {
            ngModule: MathJaxModule_1,
            providers: [
                { provide: ModuleConfiguration, useValue: moduleConfiguration },
                { provide: MathJaxService, useClass: MathJaxService },
            ]
        } : {
            ngModule: MathJaxModule_1
        };
    }
    /**
     * Configure the module for the root module.
     *
     * @param moduleConfiguration A {ModuleConfiguration} instance.
     */
    static forRoot(moduleConfiguration = {
        version: '2.7.5',
        config: 'TeX-AMS_HTML',
        hostname: 'cdnjs.cloudflare.com'
    }) {
        return {
            ngModule: MathJaxModule_1,
            providers: [
                { provide: ModuleConfiguration, useValue: moduleConfiguration },
                { provide: MathJaxService, useClass: MathJaxService },
            ]
        };
    }
    /**
     * Configure the module for a child module.
     */
    static forChild() {
        return {
            ngModule: MathJaxModule_1
        };
    }
};
MathJaxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MathJaxModule });
MathJaxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MathJaxModule_Factory(t) { return new (t || MathJaxModule)(ɵngcc0.ɵɵinject(MathJaxService), ɵngcc0.ɵɵinject(ModuleConfiguration)); }, imports: [[
            CommonModule
        ]] });
MathJaxModule = MathJaxModule_1 = __decorate([ __metadata("design:paramtypes", [MathJaxService, ModuleConfiguration])
], MathJaxModule);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MathJaxService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MathJaxDirective, [{
        type: Directive,
        args: [{
                selector: 'mathjax, [mathjax]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MathJaxService }]; }, { MathJaxExpressions: [{
            type: Input,
            args: ['mathjax']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MathJaxModule, { declarations: function () { return [MathJaxDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [MathJaxDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MathJaxModule, [{
        type: NgModule,
        args: [{
                declarations: [MathJaxDirective],
                imports: [
                    CommonModule
                ],
                exports: [MathJaxDirective]
            }]
    }], function () { return [{ type: MathJaxService }, { type: ModuleConfiguration }]; }, null); })();

export { MathJaxDirective, MathJaxModule, ModuleConfiguration, MathJaxService as ɵa };

//# sourceMappingURL=ngx-mathjax.js.map